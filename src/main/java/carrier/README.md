
- separate component, independent of producer and consumer
- API that exposes producer (e.g. RestClient) cannot both return Carrier and start producing
    - hot: start producer in thread internally
        - like Kotlin's "produce" coroutine builder
        - inflexible, to start a thread should be a choice
    - cold: return something that exposes both the Carrier and additional lifecycle control
        - awkward, not standard
- no standardization nor built-in support for a "producer" in a Java app
    - producer hot or cold? if cold how is it triggered?
    - thread management, structured or not
    - producer must hook into Carrier for autoclose
